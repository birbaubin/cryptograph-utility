import networkx as nx
from deeprobust.graph.data import Dataset
import numpy as np
from scipy.sparse import csr_matrix

def find_neighbors(graph, node_id):
    neighbors = list(graph.neighbors(node_id))
    print(f"number of neighbors of node {node_id}: {len(neighbors)}")
    print(f"Degree of node {node_id}: {graph.degree[node_id]}")
    print(f"Neighbors of node {node_id} and their labels:") 
    for neighbor in neighbors:
        print(f"Node ID: {neighbor}, Label: {graph.nodes[neighbor]['label']}")

#find the neighbor nodes with opposit label for target_node
def find_opposit_label_neighbors(graph, target_node, target_label):
    neighbor_opposit = []
    for node in graph.neighbors(target_node):
        if graph.nodes[node]['label'] != target_label:
            neighbor_opposit.append(node)
    return neighbor_opposit

#find the neighbor nodes with same label for target_node
def find_same_label_neighbors(graph, target_node, target_label):
    neighbor_same = []
    for node in graph.neighbors(target_node):
        if graph.nodes[node]['label'] == target_label:
            neighbor_same.append(node)
    return neighbor_same

#find the non_neighbor nodes with opposit label for target_node 
def find_non_neighbor_opposit_label(graph, target_node, target_label):
    non_neighbor_opposit = []
    for node in graph.nodes():
        if graph.nodes[node]['label'] != target_label and not graph.has_edge(target_node, node):
            non_neighbor_opposit.append(node)
    return non_neighbor_opposit


#find the non_neighbor nodes with same label for target_node 
def find_non_neighbor_same_label(graph, target_node, target_label):
    non_neighbor_same = []
    for node in graph.nodes():
        if graph.nodes[node]['label'] == target_label and not graph.has_edge(target_node, node):
            non_neighbor_same.append(node)
    return non_neighbor_same


def find_max_same_min_opposit_label_neighbors(graph, non_neighbor_opposit, budget ):
    max_same_min_opposit_label_neighbors = []
    for node in non_neighbor_opposit:
            num_same_neighbors = sum(1 for neighbor in graph.neighbors(node) if graph.nodes[neighbor]['label'] == graph.nodes[node]['label'])
            num_opposit_neighbors = sum(1 for neighbor in graph.neighbors(node) if graph.nodes[neighbor]['label'] != graph.nodes[node]['label'])

            p = num_same_neighbors/num_opposit_neighbors if num_opposit_neighbors != 0 else 0
            # if number of y neighbors are more than x neighbors we accept the node:
            if p > 1 :
                max_same_min_opposit_label_neighbors.append((node,num_same_neighbors,p))  
    max_same_min_opposit_label_neighbors.sort(key=lambda x: x[2], reverse=True)
    return [(node, p) for node, _ ,p in max_same_min_opposit_label_neighbors[:budget]]


#attack V_0 Mahsa
def insert_edge(graph, target_node, max_same_min_opposit_label_neighbors): 
    attacked_graph = graph.copy()
    for node, _ in max_same_min_opposit_label_neighbors:
       attacked_graph.add_edge(target_node, node)
    return attacked_graph

def convert(attacked_graph):
    # Convert the graph to a CSR matrix
    adjacency_matrix = nx.adjacency_matrix(attacked_graph)
    # Convert the adjacency matrix to CSR format
    adjacency_matrix_csr = csr_matrix(adjacency_matrix)
    return adjacency_matrix_csr
